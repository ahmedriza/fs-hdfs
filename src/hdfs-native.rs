/* automatically generated by rust-bindgen 0.59.2 */

pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type time_t = __time_t;
pub type size_t = ::std::os::raw::c_ulong;
#[doc = " Some utility decls used in libhdfs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsBuilder {
    _unused: [u8; 0],
}
#[doc = " size of data for read/write io ops"]
pub type tSize = i32;
#[doc = " time type in seconds"]
pub type tTime = time_t;
#[doc = " offset within the file"]
pub type tOffset = i64;
#[doc = " port"]
pub type tPort = u16;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tObjectKind {
    kObjectKindFile = 70,
    kObjectKindDirectory = 68,
}
#[doc = " The C reflection of org.apache.org.hadoop.FileSystem ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfs_internal {
    _unused: [u8; 0],
}
pub type hdfsFS = *mut hdfs_internal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsFile_internal {
    _unused: [u8; 0],
}
pub type hdfsFile = *mut hdfsFile_internal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hadoopRzOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hadoopRzBuffer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Determine if a file is open for read."]
    #[doc = ""]
    #[doc = " @param file     The HDFS file"]
    #[doc = " @return         1 if the file is open for read; 0 otherwise"]
    pub fn hdfsFileIsOpenForRead(file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine if a file is open for write."]
    #[doc = ""]
    #[doc = " @param file     The HDFS file"]
    #[doc = " @return         1 if the file is open for write; 0 otherwise"]
    pub fn hdfsFileIsOpenForWrite(file: hdfsFile) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsReadStatistics {
    pub totalBytesRead: u64,
    pub totalLocalBytesRead: u64,
    pub totalShortCircuitBytesRead: u64,
    pub totalZeroCopyBytesRead: u64,
}
#[test]
fn bindgen_test_layout_hdfsReadStatistics() {
    assert_eq!(
        ::std::mem::size_of::<hdfsReadStatistics>(),
        32usize,
        concat!("Size of: ", stringify!(hdfsReadStatistics))
    );
    assert_eq!(
        ::std::mem::align_of::<hdfsReadStatistics>(),
        8usize,
        concat!("Alignment of ", stringify!(hdfsReadStatistics))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsReadStatistics>())).totalBytesRead as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsReadStatistics),
            "::",
            stringify!(totalBytesRead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsReadStatistics>())).totalLocalBytesRead as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsReadStatistics),
            "::",
            stringify!(totalLocalBytesRead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsReadStatistics>())).totalShortCircuitBytesRead
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsReadStatistics),
            "::",
            stringify!(totalShortCircuitBytesRead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsReadStatistics>())).totalZeroCopyBytesRead
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsReadStatistics),
            "::",
            stringify!(totalZeroCopyBytesRead)
        )
    );
}
extern "C" {
    #[doc = " Get read statistics about a file.  This is only applicable to files"]
    #[doc = " opened for reading."]
    #[doc = ""]
    #[doc = " @param file     The HDFS file"]
    #[doc = " @param stats    (out parameter) on a successful return, the read"]
    #[doc = "                 statistics.  Unchanged otherwise.  You must free the"]
    #[doc = "                 returned statistics with hdfsFileFreeReadStatistics."]
    #[doc = " @return         0 if the statistics were successfully returned,"]
    #[doc = "                 -1 otherwise.  On a failure, please check errno against"]
    #[doc = "                 ENOTSUP.  webhdfs, LocalFilesystem, and so forth may"]
    #[doc = "                 not support read statistics."]
    pub fn hdfsFileGetReadStatistics(
        file: hdfsFile,
        stats: *mut *mut hdfsReadStatistics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param stats    HDFS read statistics for a file."]
    #[doc = ""]
    #[doc = " @return the number of remote bytes read."]
    pub fn hdfsReadStatisticsGetRemoteBytesRead(stats: *const hdfsReadStatistics) -> i64;
}
extern "C" {
    #[doc = " Clear the read statistics for a file."]
    #[doc = ""]
    #[doc = " @param file      The file to clear the read statistics of."]
    #[doc = ""]
    #[doc = " @return          0 on success; the error code otherwise."]
    #[doc = "                  EINVAL: the file is not open for reading."]
    #[doc = "                  ENOTSUP: the file does not support clearing the read"]
    #[doc = "                  statistics."]
    #[doc = "                  Errno will also be set to this code on failure."]
    pub fn hdfsFileClearReadStatistics(file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free some HDFS read statistics."]
    #[doc = ""]
    #[doc = " @param stats    The HDFS read statistics to free."]
    pub fn hdfsFileFreeReadStatistics(stats: *mut hdfsReadStatistics);
}
extern "C" {
    #[doc = " hdfsConnectAsUser - Connect to a hdfs file system as a specific user"]
    #[doc = " Connect to the hdfs."]
    #[doc = " @param nn   The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port The port on which the server is listening."]
    #[doc = " @param user the user name (this is hadoop domain user). Or NULL is equivelant to hhdfsConnect(host, port)"]
    #[doc = " @return Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated Use hdfsBuilderConnect instead."]
    pub fn hdfsConnectAsUser(
        nn: *const ::std::os::raw::c_char,
        port: tPort,
        user: *const ::std::os::raw::c_char,
    ) -> hdfsFS;
}
extern "C" {
    #[doc = " hdfsConnect - Connect to a hdfs file system."]
    #[doc = " Connect to the hdfs."]
    #[doc = " @param nn   The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port The port on which the server is listening."]
    #[doc = " @return Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated Use hdfsBuilderConnect instead."]
    pub fn hdfsConnect(nn: *const ::std::os::raw::c_char, port: tPort) -> hdfsFS;
}
extern "C" {
    #[doc = " hdfsConnect - Connect to an hdfs file system."]
    #[doc = ""]
    #[doc = " Forces a new instance to be created"]
    #[doc = ""]
    #[doc = " @param nn     The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port   The port on which the server is listening."]
    #[doc = " @param user   The user name to use when connecting"]
    #[doc = " @return       Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated   Use hdfsBuilderConnect instead."]
    pub fn hdfsConnectAsUserNewInstance(
        nn: *const ::std::os::raw::c_char,
        port: tPort,
        user: *const ::std::os::raw::c_char,
    ) -> hdfsFS;
}
extern "C" {
    #[doc = " hdfsConnect - Connect to an hdfs file system."]
    #[doc = ""]
    #[doc = " Forces a new instance to be created"]
    #[doc = ""]
    #[doc = " @param nn     The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port   The port on which the server is listening."]
    #[doc = " @return       Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated   Use hdfsBuilderConnect instead."]
    pub fn hdfsConnectNewInstance(
        nn: *const ::std::os::raw::c_char,
        port: tPort,
    ) -> hdfsFS;
}
extern "C" {
    #[doc = " Connect to HDFS using the parameters defined by the builder."]
    #[doc = ""]
    #[doc = " The HDFS builder will be freed, whether or not the connection was"]
    #[doc = " successful."]
    #[doc = ""]
    #[doc = " Every successful call to hdfsBuilderConnect should be matched with a call"]
    #[doc = " to hdfsDisconnect, when the hdfsFS is no longer needed."]
    #[doc = ""]
    #[doc = " @param bld    The HDFS builder"]
    #[doc = " @return       Returns a handle to the filesystem, or NULL on error."]
    pub fn hdfsBuilderConnect(bld: *mut hdfsBuilder) -> hdfsFS;
}
extern "C" {
    #[doc = " Create an HDFS builder."]
    #[doc = ""]
    #[doc = " @return The HDFS builder, or NULL on error."]
    pub fn hdfsNewBuilder() -> *mut hdfsBuilder;
}
extern "C" {
    #[doc = " Force the builder to always create a new instance of the FileSystem,"]
    #[doc = " rather than possibly finding one in the cache."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    pub fn hdfsBuilderSetForceNewInstance(bld: *mut hdfsBuilder);
}
extern "C" {
    #[doc = " Set the HDFS NameNode to connect to."]
    #[doc = ""]
    #[doc = " @param bld  The HDFS builder"]
    #[doc = " @param nn   The NameNode to use."]
    #[doc = "             If the string given is 'default', the default NameNode"]
    #[doc = "             configuration will be used (from the XML configuration files)"]
    #[doc = "             If NULL is given, a LocalFileSystem will be created."]
    #[doc = "             If the string starts with a protocol type such as file:// or"]
    #[doc = "             hdfs://, this protocol type will be used.  If not, the"]
    #[doc = "             hdfs:// protocol type will be used."]
    #[doc = "             You may specify a NameNode port in the usual way by"]
    #[doc = "             passing a string of the format hdfs://<hostname>:<port>."]
    #[doc = "             Alternately, you may set the port with"]
    #[doc = "             hdfsBuilderSetNameNodePort.  However, you must not pass the"]
    #[doc = "             port in two different ways."]
    pub fn hdfsBuilderSetNameNode(
        bld: *mut hdfsBuilder,
        nn: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set the port of the HDFS NameNode to connect to."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    #[doc = " @param port The port."]
    pub fn hdfsBuilderSetNameNodePort(bld: *mut hdfsBuilder, port: tPort);
}
extern "C" {
    #[doc = " Set the username to use when connecting to the HDFS cluster."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    #[doc = " @param userName The user name.  The string will be shallow-copied."]
    pub fn hdfsBuilderSetUserName(
        bld: *mut hdfsBuilder,
        userName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set the path to the Kerberos ticket cache to use when connecting to"]
    #[doc = " the HDFS cluster."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    #[doc = " @param kerbTicketCachePath The Kerberos ticket cache path.  The string"]
    #[doc = "                            will be shallow-copied."]
    pub fn hdfsBuilderSetKerbTicketCachePath(
        bld: *mut hdfsBuilder,
        kerbTicketCachePath: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Free an HDFS builder."]
    #[doc = ""]
    #[doc = " It is normally not necessary to call this function since"]
    #[doc = " hdfsBuilderConnect frees the builder."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    pub fn hdfsFreeBuilder(bld: *mut hdfsBuilder);
}
extern "C" {
    #[doc = " Set a configuration string for an HdfsBuilder."]
    #[doc = ""]
    #[doc = " @param key      The key to set."]
    #[doc = " @param val      The value, or NULL to set no value."]
    #[doc = "                 This will be shallow-copied.  You are responsible for"]
    #[doc = "                 ensuring that it remains valid until the builder is"]
    #[doc = "                 freed."]
    #[doc = ""]
    #[doc = " @return         0 on success; nonzero error code otherwise."]
    pub fn hdfsBuilderConfSetStr(
        bld: *mut hdfsBuilder,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a configuration string."]
    #[doc = ""]
    #[doc = " @param key      The key to find"]
    #[doc = " @param val      (out param) The value.  This will be set to NULL if the"]
    #[doc = "                 key isn't found.  You must free this string with"]
    #[doc = "                 hdfsConfStrFree."]
    #[doc = ""]
    #[doc = " @return         0 on success; nonzero error code otherwise."]
    #[doc = "                 Failure to find the key is not an error."]
    pub fn hdfsConfGetStr(
        key: *const ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a configuration integer."]
    #[doc = ""]
    #[doc = " @param key      The key to find"]
    #[doc = " @param val      (out param) The value.  This will NOT be changed if the"]
    #[doc = "                 key isn't found."]
    #[doc = ""]
    #[doc = " @return         0 on success; nonzero error code otherwise."]
    #[doc = "                 Failure to find the key is not an error."]
    pub fn hdfsConfGetInt(
        key: *const ::std::os::raw::c_char,
        val: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a configuration string found with hdfsConfGetStr."]
    #[doc = ""]
    #[doc = " @param val      A configuration string obtained from hdfsConfGetStr"]
    pub fn hdfsConfStrFree(val: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " hdfsDisconnect - Disconnect from the hdfs file system."]
    #[doc = " Disconnect from hdfs."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    #[doc = "         Even if there is an error, the resources associated with the"]
    #[doc = "         hdfsFS will be freed."]
    pub fn hdfsDisconnect(fs: hdfsFS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsOpenFile - Open a hdfs file in given mode."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The full path to the file."]
    #[doc = " @param flags - an | of bits/fcntl.h file flags - supported flags are O_RDONLY, O_WRONLY (meaning create or overwrite i.e., implies O_TRUNCAT),"]
    #[doc = " O_WRONLY|O_APPEND. Other flags are generally ignored other than (O_RDWR || (O_EXCL & O_CREAT)) which return NULL and set errno equal ENOTSUP."]
    #[doc = " @param bufferSize Size of buffer for read/write - pass 0 if you want"]
    #[doc = " to use the default configured values."]
    #[doc = " @param replication Block replication - pass 0 if you want to use"]
    #[doc = " the default configured values."]
    #[doc = " @param blocksize Size of block - pass 0 if you want to use the"]
    #[doc = " default configured values."]
    #[doc = " @return Returns the handle to the open file or NULL on error."]
    pub fn hdfsOpenFile(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        bufferSize: ::std::os::raw::c_int,
        replication: ::std::os::raw::c_short,
        blocksize: tSize,
    ) -> hdfsFile;
}
extern "C" {
    #[doc = " hdfsTruncateFile - Truncate a hdfs file to given lenght."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The full path to the file."]
    #[doc = " @param newlength The size the file is to be truncated to"]
    #[doc = " @return 1 if the file has been truncated to the desired newlength"]
    #[doc = "         and is immediately available to be reused for write operations"]
    #[doc = "         such as append."]
    #[doc = "         0 if a background process of adjusting the length of the last"]
    #[doc = "         block has been started, and clients should wait for it to"]
    #[doc = "         complete before proceeding with further file updates."]
    #[doc = "         -1 on error."]
    pub fn hdfsTruncateFile(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        newlength: tOffset,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsUnbufferFile - Reduce the buffering done on a file."]
    #[doc = ""]
    #[doc = " @param file  The file to unbuffer."]
    #[doc = " @return      0 on success"]
    #[doc = "              ENOTSUP if the file does not support unbuffering"]
    #[doc = "              Errno will also be set to this value."]
    pub fn hdfsUnbufferFile(file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsCloseFile - Close an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    #[doc = "         On error, errno will be set appropriately."]
    #[doc = "         If the hdfs file was valid, the memory associated with it will"]
    #[doc = "         be freed at the end of this call, even if there was an I/O"]
    #[doc = "         error."]
    pub fn hdfsCloseFile(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsExists - Checks if a given path exsits on the filesystem"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path to look for"]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsExists(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsSeek - Seek to given offset in file."]
    #[doc = " This works only for files opened in read-only mode."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param desiredPos Offset into the file to seek into."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsSeek(
        fs: hdfsFS,
        file: hdfsFile,
        desiredPos: tOffset,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsTell - Get the current offset in the file, in bytes."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Current offset, -1 on error."]
    pub fn hdfsTell(fs: hdfsFS, file: hdfsFile) -> tOffset;
}
extern "C" {
    #[doc = " hdfsRead - Read data from an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param buffer The buffer to copy read bytes into."]
    #[doc = " @param length The length of the buffer."]
    #[doc = " @return      On success, a positive number indicating how many bytes"]
    #[doc = "              were read."]
    #[doc = "              On end-of-file, 0."]
    #[doc = "              On error, -1.  Errno will be set to the error code."]
    #[doc = "              Just like the POSIX read function, hdfsRead will return -1"]
    #[doc = "              and set errno to EINTR if data is temporarily unavailable,"]
    #[doc = "              but we are not yet at the end of the file."]
    pub fn hdfsRead(
        fs: hdfsFS,
        file: hdfsFile,
        buffer: *mut ::std::os::raw::c_void,
        length: tSize,
    ) -> tSize;
}
extern "C" {
    #[doc = " hdfsPread - Positional read of data from an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param position Position from which to read"]
    #[doc = " @param buffer The buffer to copy read bytes into."]
    #[doc = " @param length The length of the buffer."]
    #[doc = " @return      See hdfsRead"]
    pub fn hdfsPread(
        fs: hdfsFS,
        file: hdfsFile,
        position: tOffset,
        buffer: *mut ::std::os::raw::c_void,
        length: tSize,
    ) -> tSize;
}
extern "C" {
    #[doc = " hdfsWrite - Write data into an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param buffer The data."]
    #[doc = " @param length The no. of bytes to write."]
    #[doc = " @return Returns the number of bytes written, -1 on error."]
    pub fn hdfsWrite(
        fs: hdfsFS,
        file: hdfsFile,
        buffer: *const ::std::os::raw::c_void,
        length: tSize,
    ) -> tSize;
}
extern "C" {
    #[doc = " hdfsWrite - Flush the data."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsFlush(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsHFlush - Flush out the data in client's user buffer. After the"]
    #[doc = " return of this call, new readers will see the data."]
    #[doc = " @param fs configured filesystem handle"]
    #[doc = " @param file file handle"]
    #[doc = " @return 0 on success, -1 on error and sets errno"]
    pub fn hdfsHFlush(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsHSync - Similar to posix fsync, Flush out the data in client's"]
    #[doc = " user buffer. all the way to the disk device (but the disk may have"]
    #[doc = " it in its cache)."]
    #[doc = " @param fs configured filesystem handle"]
    #[doc = " @param file file handle"]
    #[doc = " @return 0 on success, -1 on error and sets errno"]
    pub fn hdfsHSync(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsAvailable - Number of bytes that can be read from this"]
    #[doc = " input stream without blocking."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Returns available bytes; -1 on error."]
    pub fn hdfsAvailable(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsCopy - Copy file from one filesystem to another."]
    #[doc = " @param srcFS The handle to source filesystem."]
    #[doc = " @param src The path of source file."]
    #[doc = " @param dstFS The handle to destination filesystem."]
    #[doc = " @param dst The path of destination file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsCopy(
        srcFS: hdfsFS,
        src: *const ::std::os::raw::c_char,
        dstFS: hdfsFS,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsMove - Move file from one filesystem to another."]
    #[doc = " @param srcFS The handle to source filesystem."]
    #[doc = " @param src The path of source file."]
    #[doc = " @param dstFS The handle to destination filesystem."]
    #[doc = " @param dst The path of destination file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsMove(
        srcFS: hdfsFS,
        src: *const ::std::os::raw::c_char,
        dstFS: hdfsFS,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsDelete - Delete file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @param recursive if path is a directory and set to"]
    #[doc = " non-zero, the directory is deleted else throws an exception. In"]
    #[doc = " case of a file the recursive argument is irrelevant."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsDelete(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        recursive: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsRename - Rename file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param oldPath The path of the source file."]
    #[doc = " @param newPath The path of the destination file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsRename(
        fs: hdfsFS,
        oldPath: *const ::std::os::raw::c_char,
        newPath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsGetWorkingDirectory - Get the current working directory for"]
    #[doc = " the given filesystem."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param buffer The user-buffer to copy path of cwd into."]
    #[doc = " @param bufferSize The length of user-buffer."]
    #[doc = " @return Returns buffer, NULL on error."]
    pub fn hdfsGetWorkingDirectory(
        fs: hdfsFS,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " hdfsSetWorkingDirectory - Set the working directory. All relative"]
    #[doc = " paths will be resolved relative to it."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the new 'cwd'."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsSetWorkingDirectory(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsCreateDirectory - Make the given file and all non-existent"]
    #[doc = " parents into directories."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the directory."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsCreateDirectory(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsSetReplication - Set the replication of the specified"]
    #[doc = " file to the supplied value"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsSetReplication(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        replication: i16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " hdfsFileInfo - Information about a file/directory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsFileInfo {
    pub mKind: tObjectKind,
    pub mName: *mut ::std::os::raw::c_char,
    pub mLastMod: tTime,
    pub mSize: tOffset,
    pub mReplication: ::std::os::raw::c_short,
    pub mBlockSize: tOffset,
    pub mOwner: *mut ::std::os::raw::c_char,
    pub mGroup: *mut ::std::os::raw::c_char,
    pub mPermissions: ::std::os::raw::c_short,
    pub mLastAccess: tTime,
}
#[test]
fn bindgen_test_layout_hdfsFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<hdfsFileInfo>(),
        80usize,
        concat!("Size of: ", stringify!(hdfsFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<hdfsFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(hdfsFileInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hdfsFileInfo>())).mKind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mKind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hdfsFileInfo>())).mName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hdfsFileInfo>())).mLastMod as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mLastMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hdfsFileInfo>())).mSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsFileInfo>())).mReplication as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mReplication)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsFileInfo>())).mBlockSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mBlockSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hdfsFileInfo>())).mOwner as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mOwner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hdfsFileInfo>())).mGroup as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsFileInfo>())).mPermissions as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mPermissions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hdfsFileInfo>())).mLastAccess as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hdfsFileInfo),
            "::",
            stringify!(mLastAccess)
        )
    );
}
extern "C" {
    #[doc = " hdfsListDirectory - Get list of files/directories for a given"]
    #[doc = " directory-path. hdfsFreeFileInfo should be called to deallocate memory."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the directory."]
    #[doc = " @param numEntries Set to the number of files/directories in path."]
    #[doc = " @return Returns a dynamically-allocated array of hdfsFileInfo"]
    #[doc = " objects; NULL on error."]
    pub fn hdfsListDirectory(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        numEntries: *mut ::std::os::raw::c_int,
    ) -> *mut hdfsFileInfo;
}
extern "C" {
    #[doc = " hdfsGetPathInfo - Get information about a path as a (dynamically"]
    #[doc = " allocated) single hdfsFileInfo struct. hdfsFreeFileInfo should be"]
    #[doc = " called when the pointer is no longer needed."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @return Returns a dynamically-allocated hdfsFileInfo object;"]
    #[doc = " NULL on error."]
    pub fn hdfsGetPathInfo(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> *mut hdfsFileInfo;
}
extern "C" {
    #[doc = " hdfsFreeFileInfo - Free up the hdfsFileInfo array (including fields)"]
    #[doc = " @param hdfsFileInfo The array of dynamically-allocated hdfsFileInfo"]
    #[doc = " objects."]
    #[doc = " @param numEntries The size of the array."]
    pub fn hdfsFreeFileInfo(
        hdfsFileInfo: *mut hdfsFileInfo,
        numEntries: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " hdfsFileIsEncrypted: determine if a file is encrypted based on its"]
    #[doc = " hdfsFileInfo."]
    #[doc = " @return -1 if there was an error (errno will be set), 0 if the file is"]
    #[doc = "         not encrypted, 1 if the file is encrypted."]
    pub fn hdfsFileIsEncrypted(hdfsFileInfo: *mut hdfsFileInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsGetHosts - Get hostnames where a particular block (determined by"]
    #[doc = " pos & blocksize) of a file is stored. The last element in the array"]
    #[doc = " is NULL. Due to replication, a single block could be present on"]
    #[doc = " multiple hosts."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @param start The start of the block."]
    #[doc = " @param length The length of the block."]
    #[doc = " @return Returns a dynamically-allocated 2-d array of blocks-hosts;"]
    #[doc = " NULL on error."]
    pub fn hdfsGetHosts(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        start: tOffset,
        length: tOffset,
    ) -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " hdfsFreeHosts - Free up the structure returned by hdfsGetHosts"]
    #[doc = " @param hdfsFileInfo The array of dynamically-allocated hdfsFileInfo"]
    #[doc = " objects."]
    #[doc = " @param numEntries The size of the array."]
    pub fn hdfsFreeHosts(blockHosts: *mut *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " hdfsGetDefaultBlockSize - Get the default blocksize."]
    #[doc = ""]
    #[doc = " @param fs            The configured filesystem handle."]
    #[doc = " @deprecated          Use hdfsGetDefaultBlockSizeAtPath instead."]
    #[doc = ""]
    #[doc = " @return              Returns the default blocksize, or -1 on error."]
    pub fn hdfsGetDefaultBlockSize(fs: hdfsFS) -> tOffset;
}
extern "C" {
    #[doc = " hdfsGetDefaultBlockSizeAtPath - Get the default blocksize at the"]
    #[doc = " filesystem indicated by a given path."]
    #[doc = ""]
    #[doc = " @param fs            The configured filesystem handle."]
    #[doc = " @param path          The given path will be used to locate the actual"]
    #[doc = "                      filesystem.  The full path does not have to exist."]
    #[doc = ""]
    #[doc = " @return              Returns the default blocksize, or -1 on error."]
    pub fn hdfsGetDefaultBlockSizeAtPath(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> tOffset;
}
extern "C" {
    #[doc = " hdfsGetCapacity - Return the raw capacity of the filesystem."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @return Returns the raw-capacity; -1 on error."]
    pub fn hdfsGetCapacity(fs: hdfsFS) -> tOffset;
}
extern "C" {
    #[doc = " hdfsGetUsed - Return the total raw size of all files in the filesystem."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @return Returns the total-size; -1 on error."]
    pub fn hdfsGetUsed(fs: hdfsFS) -> tOffset;
}
extern "C" {
    #[doc = " Change the user and/or group of a file or directory."]
    #[doc = ""]
    #[doc = " @param fs            The configured filesystem handle."]
    #[doc = " @param path          the path to the file or directory"]
    #[doc = " @param owner         User string.  Set to NULL for 'no change'"]
    #[doc = " @param group         Group string.  Set to NULL for 'no change'"]
    #[doc = " @return              0 on success else -1"]
    pub fn hdfsChown(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        owner: *const ::std::os::raw::c_char,
        group: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsChmod"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path the path to the file or directory"]
    #[doc = " @param mode the bitmask to set it to"]
    #[doc = " @return 0 on success else -1"]
    pub fn hdfsChmod(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsUtime"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path the path to the file or directory"]
    #[doc = " @param mtime new modification time or -1 for no change"]
    #[doc = " @param atime new access time or -1 for no change"]
    #[doc = " @return 0 on success else -1"]
    pub fn hdfsUtime(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        mtime: tTime,
        atime: tTime,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a zero-copy options structure."]
    #[doc = ""]
    #[doc = " You must free all options structures allocated with this function using"]
    #[doc = " hadoopRzOptionsFree."]
    #[doc = ""]
    #[doc = " @return            A zero-copy options structure, or NULL if one could"]
    #[doc = "                    not be allocated.  If NULL is returned, errno will"]
    #[doc = "                    contain the error number."]
    pub fn hadoopRzOptionsAlloc() -> *mut hadoopRzOptions;
}
extern "C" {
    #[doc = " Determine whether we should skip checksums in read0."]
    #[doc = ""]
    #[doc = " @param opts        The options structure."]
    #[doc = " @param skip        Nonzero to skip checksums sometimes; zero to always"]
    #[doc = "                    check them."]
    #[doc = ""]
    #[doc = " @return            0 on success; -1 plus errno on failure."]
    pub fn hadoopRzOptionsSetSkipChecksum(
        opts: *mut hadoopRzOptions,
        skip: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the ByteBufferPool to use with read0."]
    #[doc = ""]
    #[doc = " @param opts        The options structure."]
    #[doc = " @param className   If this is NULL, we will not use any"]
    #[doc = "                    ByteBufferPool.  If this is non-NULL, it will be"]
    #[doc = "                    treated as the name of the pool class to use."]
    #[doc = "                    For example, you can use"]
    #[doc = "                    ELASTIC_BYTE_BUFFER_POOL_CLASS."]
    #[doc = ""]
    #[doc = " @return            0 if the ByteBufferPool class was found and"]
    #[doc = "                    instantiated;"]
    #[doc = "                    -1 plus errno otherwise."]
    pub fn hadoopRzOptionsSetByteBufferPool(
        opts: *mut hadoopRzOptions,
        className: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a hadoopRzOptionsFree structure."]
    #[doc = ""]
    #[doc = " @param opts        The options structure to free."]
    #[doc = "                    Any associated ByteBufferPool will also be freed."]
    pub fn hadoopRzOptionsFree(opts: *mut hadoopRzOptions);
}
extern "C" {
    #[doc = " Perform a byte buffer read."]
    #[doc = " If possible, this will be a zero-copy (mmap) read."]
    #[doc = ""]
    #[doc = " @param file       The file to read from."]
    #[doc = " @param opts       An options structure created by hadoopRzOptionsAlloc."]
    #[doc = " @param maxLength  The maximum length to read.  We may read fewer bytes"]
    #[doc = "                   than this length."]
    #[doc = ""]
    #[doc = " @return           On success, we will return a new hadoopRzBuffer."]
    #[doc = "                   This buffer will continue to be valid and readable"]
    #[doc = "                   until it is released by readZeroBufferFree.  Failure to"]
    #[doc = "                   release a buffer will lead to a memory leak."]
    #[doc = "                   You can access the data within the hadoopRzBuffer with"]
    #[doc = "                   hadoopRzBufferGet.  If you have reached EOF, the data"]
    #[doc = "                   within the hadoopRzBuffer will be NULL.  You must still"]
    #[doc = "                   free hadoopRzBuffer instances containing NULL."]
    #[doc = "                   On failure, we will return NULL plus an errno code."]
    #[doc = "                   errno = EOPNOTSUPP indicates that we could not do a"]
    #[doc = "                   zero-copy read, and there was no ByteBufferPool"]
    #[doc = "                   supplied."]
    pub fn hadoopReadZero(
        file: hdfsFile,
        opts: *mut hadoopRzOptions,
        maxLength: i32,
    ) -> *mut hadoopRzBuffer;
}
extern "C" {
    #[doc = " Determine the length of the buffer returned from readZero."]
    #[doc = ""]
    #[doc = " @param buffer     a buffer returned from readZero."]
    #[doc = " @return           the length of the buffer."]
    pub fn hadoopRzBufferLength(buffer: *const hadoopRzBuffer) -> i32;
}
extern "C" {
    #[doc = " Get a pointer to the raw buffer returned from readZero."]
    #[doc = ""]
    #[doc = " To find out how many bytes this buffer contains, call"]
    #[doc = " hadoopRzBufferLength."]
    #[doc = ""]
    #[doc = " @param buffer     a buffer returned from readZero."]
    #[doc = " @return           a pointer to the start of the buffer.  This will be"]
    #[doc = "                   NULL when end-of-file has been reached."]
    pub fn hadoopRzBufferGet(
        buffer: *const hadoopRzBuffer,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Release a buffer obtained through readZero."]
    #[doc = ""]
    #[doc = " @param file       The hdfs stream that created this buffer.  This must be"]
    #[doc = "                   the same stream you called hadoopReadZero on."]
    #[doc = " @param buffer     The buffer to release."]
    pub fn hadoopRzBufferFree(file: hdfsFile, buffer: *mut hadoopRzBuffer);
}
pub type jint = ::std::os::raw::c_int;
pub type jboolean = ::std::os::raw::c_uchar;
#[doc = " <div rustbindgen replaces=\"MiniDfsCluster\"></div>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiniDfsCluster {
    _unused: [u8; 0],
}
#[doc = " <div rustbindgen replaces=\"MiniDfsConf\"></div>"]
#[doc = ""]
#[doc = " Represents a configuration to use for creating a Native MiniDFSCluster"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiniDfsConf {
    #[doc = " Nonzero if the cluster should be formatted prior to startup."]
    pub doFormat: jboolean,
    #[doc = " Whether or not to enable webhdfs in MiniDfsCluster"]
    pub webhdfsEnabled: jboolean,
    #[doc = " The http port of the namenode in MiniDfsCluster"]
    pub namenodeHttpPort: jint,
    #[doc = " Nonzero if we should configure short circuit."]
    pub configureShortCircuit: jboolean,
}
#[test]
fn bindgen_test_layout_MiniDfsConf() {
    assert_eq!(
        ::std::mem::size_of::<MiniDfsConf>(),
        12usize,
        concat!("Size of: ", stringify!(MiniDfsConf))
    );
    assert_eq!(
        ::std::mem::align_of::<MiniDfsConf>(),
        4usize,
        concat!("Alignment of ", stringify!(MiniDfsConf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MiniDfsConf>())).doFormat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MiniDfsConf),
            "::",
            stringify!(doFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MiniDfsConf>())).webhdfsEnabled as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MiniDfsConf),
            "::",
            stringify!(webhdfsEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MiniDfsConf>())).namenodeHttpPort as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MiniDfsConf),
            "::",
            stringify!(namenodeHttpPort)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MiniDfsConf>())).configureShortCircuit as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MiniDfsConf),
            "::",
            stringify!(configureShortCircuit)
        )
    );
}
extern "C" {
    #[doc = " Create a NativeMiniDfsBuilder"]
    #[doc = ""]
    #[doc = " @param conf      (inout) The cluster configuration"]
    #[doc = ""]
    #[doc = " @return      a NativeMiniDfsBuilder, or a NULL pointer on error."]
    pub fn nmdCreate(conf: *const MiniDfsConf) -> *mut MiniDfsCluster;
}
extern "C" {
    #[doc = " Wait until a MiniDFSCluster comes out of safe mode."]
    #[doc = ""]
    #[doc = " @param cl        The cluster"]
    #[doc = ""]
    #[doc = " @return          0 on success; a non-zero error code if the cluster fails to"]
    #[doc = "                  come out of safe mode."]
    pub fn nmdWaitClusterUp(cl: *mut MiniDfsCluster) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shut down a NativeMiniDFS cluster"]
    #[doc = ""]
    #[doc = " @param cl        The cluster"]
    #[doc = ""]
    #[doc = " @return          0 on success; a non-zero error code if an exception is"]
    #[doc = "                  thrown."]
    pub fn nmdShutdown(cl: *mut MiniDfsCluster) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shut down a NativeMiniDFS cluster with deleting hdfs directory"]
    #[doc = ""]
    #[doc = " @param cl        The cluster"]
    #[doc = ""]
    #[doc = " @return          0 on success; a non-zero error code if an exception is"]
    #[doc = "                  thrown."]
    pub fn nmdShutdownClean(cl: *mut MiniDfsCluster) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a Native MiniDFSCluster"]
    #[doc = ""]
    #[doc = " @param cl        The cluster to destroy"]
    pub fn nmdFree(cl: *mut MiniDfsCluster);
}
extern "C" {
    #[doc = " Get the port that's in use by the given (non-HA) nativeMiniDfs"]
    #[doc = ""]
    #[doc = " @param cl        The initialized NativeMiniDfsCluster"]
    #[doc = ""]
    #[doc = " @return          the port, or a negative error code"]
    pub fn nmdGetNameNodePort(cl: *const MiniDfsCluster) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the http address that's in use by the given (non-HA) nativeMiniDfs"]
    #[doc = ""]
    #[doc = " @param cl        The initialized NativeMiniDfsCluster"]
    #[doc = " @param port      Used to capture the http port of the NameNode"]
    #[doc = "                  of the NativeMiniDfsCluster"]
    #[doc = " @param hostName  Used to capture the http hostname of the NameNode"]
    #[doc = "                  of the NativeMiniDfsCluster"]
    #[doc = ""]
    #[doc = " @return          0 on success; a non-zero error code if failing to"]
    #[doc = "                  get the information."]
    pub fn nmdGetNameNodeHttpAddress(
        cl: *const MiniDfsCluster,
        port: *mut ::std::os::raw::c_int,
        hostName: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get domain socket path set for this cluster."]
    #[doc = ""]
    #[doc = " @param cl        The cluster"]
    #[doc = ""]
    #[doc = " @return          A const string of domain socket path, or NULL if not set."]
    pub fn hdfsGetDomainSocketPath(
        cl: *const MiniDfsCluster,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Configure the HDFS builder appropriately to connect to this cluster."]
    #[doc = ""]
    #[doc = " @param bld       The hdfs builder"]
    #[doc = ""]
    #[doc = " @return          the port, or a negative error code"]
    pub fn nmdConfigureHdfsBuilder(
        cl: *mut MiniDfsCluster,
        bld: *mut hdfsBuilder,
    ) -> ::std::os::raw::c_int;
}
